# -*- coding: utf-8 -*-
"""Portfolio Optimisation - Clean.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HPwVhR31QTRGwC1x8n56DazlMrB9Dpsh
"""

from pandas_datareader import data as web
import pandas as pd
import numpy as np
from datetime import datetime
import matplotlib.pyplot as plt
plt.style.use('fivethirtyeight')

stocks = ["AAPL","MSFT"]
# Bigger list of companies (total 50)
# stocks = ["AAPL","MSFT","AMZN","GOOG","FB","TSLA","GOOGL","NVDA","CMCSA","ADBE","INTC","CSCO","NFLX","PEP","AVGO","TMUS","TXN","COST","AMGN","CHTR","SBUX","AMAT","INTU","ISRG","AMD","BKNG","MU","LRCX","MDLZ","ADP","GILD","FISV","CSX","ATVI","MELI","ADSK","ADI","ILMN","NXPI","BIDU","VRTX","REGN","ASML","KDP","MNST","KLAC","ROST","MAR","IDXX","ALGN"]

companies = len(stocks)
gold = False
asset_num = companies + gold
working_days = 252 # 252 working days in a year

"""### Dates for return data"""

stockStartDate = '2013-01-01'
today = datetime.today().strftime("%Y-%m-%d")
today

"""### Create a Dataframe for stocks + gold
We have extracted the daily returns of various stocks and gold from data sources such as "yahoo" and "fred".
"""

df = pd.DataFrame()

for stock in stocks:
  df[stock] = web.DataReader(stock, data_source="yahoo",start=stockStartDate,end=today)["Adj Close"]

if gold:
  df["GOLD"] = web.DataReader("GOLDAMGBD228NLBM", data_source="fred", start=stockStartDate, end=today)

df

"""### Trends
We can view the trends of these stocks as a line graph over the time period specified.
"""

title = "Portfolio Adj. Close Price History"
my_stocks = df
for c in my_stocks.columns.values:
  plt.plot(my_stocks[c],label=c)
plt.title(title)
plt.xlabel("Date",fontsize = 18)
plt.ylabel("Adj. Price USD",fontsize=18)
plt.legend(my_stocks.columns.values,loc="upper left")
plt.show()

"""### Calculate return percentage
Returns a percentage change in the stock over a day.
We use the following formula for it

(New Return - Old Return) / Old Return
"""

returns = df.pct_change()
returns

"""### Covariance between stocks
Given n stocks, the function pandas.DataFrame.cov() calculates the pairwise covariance between all stocks using the change in returns in each column, that is, the returns for each individual stock.
"""

cov_matrix_annual = returns.cov()*252
cov_matrix_annual

"""Average yearly return for every company over the time period under consideration."""

means = returns.mean(axis=0)*252

"""## Constrained Optimisation
We will use the technique of constrained to obtain a solution, that is, a portfolio with the desired properties.
Our objective will be to minimise the risk for a given expected return. 
The risk term will contain all the terms in the covariance matrix obtained.
Refer: https://medium.com/swlh/portfolio-optimization-from-scratch-925f66c4020d for more details.
The Lagrangian consists of

1.   The objective function as described above
2.   A function that equates the total mean of the portfolio with the weighted mean of all the stocks
3.   Sum of all weights equals one.
4.   Constraints stating that all weights have to be non-negative.

Add a column with the negative of the mean for all the rows corresponding to differentiation with respect to the weights (the first n rows, where n is the number of stocks).
"""

cov_matrix_annual["Mean"] = means
cov_matrix_annual["Mean"]

"""Converting the dataframe to 2-D list, since that is easier to manipulate."""

matrix = cov_matrix_annual.to_numpy().tolist()

"""Add a row containing the mean of the ith stock"""

matrix.append(means.to_list()+[0])

"""Add rows of all 1s."""

matrix.append([1]*len(cov_matrix_annual)+[0])

"""Add a column of -1s for each of the first n equations."""

for i in range(len(matrix)-2):
  matrix[i].append(1.00)
matrix[-1].append(0.0000)
matrix[-2].append(0.0000)
# We now have an (n + 2) x (n + 2) matrix

print(matrix)

"""When we differentiate wrt to the weights, we get the following additional terms from the 4th type of terms in the Lagrangian."""

# for i in range(asset_num+2):
#   for j in range(asset_num):
#     matrix[i].append(-1.0000*(j==i))

"""Finally, to ensure weights are non-negative."""

# for i in range(asset_num):
  # matrix.append([-1.0000*(j==i) for j in range(2*asset_num+2)])

"""### Solving matrix equation AX = B"""

"""
L = f(ki,...) + l1*g1(ki,...) +l2*g2(ki,...) + s1*(-k1)+s2*(-k2)+...

[... s1 s2 s3]
[     -1  0  0]
.      0 -1 0
.      0 0 -1
.      0 0 0
.      0 0 0
[-1 0 0 0  0  0]
[0 -1 0 0  0  0]
[0 0 -1 0  0  0]

A
[

1
1
]

X = [k1, k2, ... kn, l1, l2, u1, u2, ... un]

B = [0 ... 0, up, 1, 0 ... 0]
"""

A = np.array(matrix)

# For a given expected return, find out actual return obtained, and the volatility of the portfolio
returnsActual = []
volatilities = []

# -1 will be replaced with the expected that we want

for expected_return in [0.01*j for j in range(1, 44)]:
  # B = np.array([0 for i in range(asset_num)] + [expected_return , 1] + [0 for i in range(asset_num)])
  B = np.array([0 for i in range(asset_num)] + [expected_return , 1])

  X = np.linalg.pinv(A) @ B

  # These are the weights for buying the stocks in order to obtain the expected return
  weights = X[:asset_num]

  # However, it may not be possible to achieve such returns.
  # The returns we obtain may be slightly different from the expected returns.
  returnsActual.append(sum([weights[i] * means[i] for i in range(asset_num)]))


  volatility = 0
  for i in range(asset_num):
    for j in range(asset_num):
      volatility += (cov_matrix_annual.iloc[i][j] * weights[i] * weights[j])
  volatilities.append(np.sqrt(volatility))

  print(weights,expected_return)
  # print(round(returnsActual[-1], 2), round(expected_return, 2))
  # print(round(returnsActual[-1], 2), round(np.sqrt(volatility), 2))

"""## Volatility vs Achieved Returns"""

plt.plot(volatilities, returnsActual)
plt.xlabel("Volatilties", fontsize = 18)
plt.ylabel("Achieved Returns", fontsize=18)
# plt.legend(my_stocks.columns.values,loc="upper left")
plt.show()

"""### Risk
For given weights
"""

weights = X[:asset_num]
# weights = [0.2, 0.2, 0.2, 0.2, 0.2]
print("Return: " + str(sum([weights[i]*means[i] for i in range(asset_num)])))
volatility = 0
for i in range(asset_num):
  for j in range(asset_num):
    volatility+=(cov_matrix_annual.iloc[i][j]*weights[i]*weights[j])
print("Risk: " + str(np.sqrt(volatility)))

print(weights)

print(sum(weights))

"""Remove the extra column from the dataframe"""

del cov_matrix_annual['Mean']

port_variance = np.dot(weights.T,np.dot(cov_matrix_annual,weights))
port_variance

port_volatility = np.sqrt(port_variance)
port_volatility

portfolioSimpleAnnualReturn = np.sum(returns.mean()*weights)*252
portfolioSimpleAnnualReturn

percent_var = str(round(port_variance,2)*100)+"%"
percent_vols = str(round(port_volatility,2)*100)+"%"
percent_ret = str(round(portfolioSimpleAnnualReturn,2)*100)+"%"
print("Expected annual return: "+percent_ret)
print("Annual volatility / risk: "+percent_vols)
print("Annual variance: "+percent_var)

pip install PyPortfolioOpt

from pypfopt.efficient_frontier import EfficientFrontier
from pypfopt import risk_models, expected_returns

mu = expected_returns.mean_historical_return(df)  
S = risk_models.sample_cov(df)
ef = EfficientFrontier(mu,S)
weights = ef.max_sharpe()
cleaned_weights = ef.clean_weights()
print(cleaned_weights)
ef.portfolio_performance(verbose=True)

from pypfopt.discrete_allocation import DiscreteAllocation, get_latest_prices
 latest_prices = get_latest_prices(df)
 weights = cleaned_weights
 da = DiscreteAllocation(weights,latest_prices,total_portfolio_value=15000)
 allocation,leftover = da.lp_portfolio()
 print("Discrete Allcation: ", allocation)
 print("Funds Remaining: ${:.2f}".format(leftover))

